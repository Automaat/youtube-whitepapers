Generate 11 presentation slides based on the podcast about RFC 2616: HTTP/1.1.

## Visual Style
- Minimal, clean design with dark blue headers
- White/light gray background
- Sans-serif typography throughout
- Simple outline icons only (no stock photos, no AI-generated images)
- Consistent layout: title at top, bullets left-aligned
- Same spacing and margins across all slides
- Use diagrams/flowcharts for technical concepts where appropriate

---

## Slide 1: The Early Internet Crisis
- Late 1990s web was slow and becoming unusable
- HTTP/1.0 created separate connection for each resource
- Loading a page with 10 images = 11 separate connections
- Network couldn't scale to handle multimedia and millions of users
- RFC 2616 (1999) saved the internet from collapsing under its own weight

## Slide 2: Three Revolutionary Pillars
- Performance optimization through persistent connections
- Rich application layer via standardized methods and status codes
- Intelligent caching to eliminate redundant transfers
- These pillars enabled efficiency, scalability, and flexibility
- Transformed web from simple document reader to universal application platform

## Slide 3: Persistent Connections
- HTTP/1.0: one request per connection (like hanging up phone after each sentence)
- HTTP/1.1: connections stay open by default
- Browser sends multiple requests over single connection
- Connection: close header allows fallback to old behavior
- Dramatically reduced overhead and page load times

## Slide 4: HTTP Methods - Universal Grammar
- Request structure: method (verb) + resource (noun) + version
- GET: retrieve resource (safe operation, doesn't modify server state)
- POST: send data for processing (forms, comments)
- PUT: place resource at specific location
- DELETE: remove specified resource

## Slide 5: Idempotency and Reliability
- Idempotent operations: same result whether executed once or multiple times
- GET, PUT, DELETE are idempotent (like elevator call button)
- POST is not idempotent (each submit creates new comment)
- Critical concept for building predictable distributed systems
- Enables retry logic and failure recovery

## Slide 6: HTTP Status Codes - Five Classes
- First digit determines category of response
- 1xx: informational (rarely used)
- 2xx: success (200 OK - request succeeded)
- 3xx: redirection (resource moved to different location)
- 4xx: client error (404 Not Found - your mistake)
- 5xx: server error (500 Internal Server Error - server's fault)

## Slide 7: Caching with Expires and Cache-Control
- Fastest request is one you don't have to send
- Early approach: Expires header with absolute date (fragile, clock sync issues)
- Cache-Control with max-age directive: relative time from receipt
- max-age=3600 means valid for 1 hour from download
- Eliminated clock synchronization problems

## Slide 8: Conditional Requests and ETags
- When cached resource expires, don't blindly re-download
- ETag: version identifier for resource (like document version number)
- Browser sends If-None-Match: "version-5"
- Server responds 304 Not Modified if unchanged
- Exchange kilobytes of headers instead of megabytes of content

## Slide 9: Virtual Hosting and Scalability
- Pre-1.1: one IP address = one website (like each apartment needing unique street address)
- HOST header (mandatory in 1.1): multiple domains on single IP
- Browser specifies which site it wants via HOST header
- Democratized web hosting - made owning a website cheap and accessible
- Foundation for modern CDN networks

## Slide 10: Content Negotiation and Flexibility
- Accept-Language header: browser requests preferred language
- Accept-Encoding: browser declares compression support (gzip)
- Server adapts response based on client capabilities
- Web became adaptable instead of monolithic
- Enabled multilingual, optimized content delivery

## Slide 11: Question for You
How has the balance shifted over these decades between the incredible functionality that HTTP/1.1 gave us and the privacy threats that were identified so early and accurately in its foundational design?
