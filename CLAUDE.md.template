# [Project Name]

<!--
CLAUDE.md Template
This file is automatically read by Claude Code at the start of every conversation.
Keep it under 500 lines for optimal performance.
Version control this file and share with your team.
-->

## Overview

<!-- Brief 2-3 sentence description of the project -->
[Brief project description - what it does, who it's for]

**Tech Stack:** [Primary language(s), frameworks, key technologies]

**Purpose:** [Primary goal or problem this project solves]

---

## Project Structure

<!-- Document directory layout and key modules -->

### Directory Layout

```
/cmd/              # [If Go: Main applications, one per executable]
/src/              # [Or equivalent source directory]
/internal/         # [Private/internal packages]
/pkg/              # [Public libraries]
/api/              # [API definitions, specs]
/scripts/          # [Build, deploy, utility scripts]
/tests/            # [Test files]
/docs/             # [Documentation]
/[other dirs]      # [Project-specific directories]
```

### Key Modules

- **[Module Name]** - [Brief description, location]
- **[Module Name]** - [Brief description, location]
- **[Module Name]** - [Brief description, location]

<!-- For large codebases, reference subdirectory CLAUDE.md files -->
<!-- See ./backend/CLAUDE.md for backend-specific patterns -->
<!-- See ./infra/CLAUDE.md for infrastructure patterns -->

---

## Development Workflow

### Before Coding

<!-- Instructions to prevent Claude from jumping straight to code -->

1. **ASK clarifying questions** until 95% confident about requirements
2. **Research existing patterns** in codebase
3. **Create plan** and get approval before implementing
4. **Work incrementally** - one focused task at a time

### Recommended Workflow

**Explore → Plan → Code → Commit**

- Use **Plan Mode** (Shift+Tab twice) for complex tasks
- Search codebase for similar implementations before proposing new patterns
- Propose plan with alternatives when multiple approaches exist
- **Do NOT code until plan is confirmed**

---

## [Language] Conventions

<!-- Replace [Language] with your primary language: Go, TypeScript, Python, etc. -->

### Code Style

- **Formatter:** [e.g., gofmt, prettier, black]
- **Linter:** [e.g., golangci-lint, ESLint, pylint]
- **Naming conventions:** [camelCase, snake_case, PascalCase]
- **Indentation:** [spaces/tabs, size]
- **Line length:** [max characters]

### Linter Errors

**ALWAYS:**
- Attempt to fix linter errors properly
- Research solutions online if unclear how to fix
- Fix root cause, not symptoms

**NEVER:**
- Use skip/disable directives (e.g., `// eslint-disable`, `# noqa`, `//nolint`)
- Ignore linter warnings
- Work around linter errors

**If stuck:**
- Try fixing the error
- Research online for proper solution
- If still unclear after research, ASK what to do (don't skip/disable)

### [Language-Specific Patterns]

<!-- For Go -->
<!--
- Error handling: Return errors as last value
- Check explicitly: `if err != nil`
- Wrap with context: `fmt.Errorf("operation: %w", err)`
- Use errors.Is/errors.As for inspection
- Early returns for errors (happy path last)
- NO panic except exceptional cases
-->

<!-- For TypeScript/JavaScript -->
<!--
- Prefer const over let, never var
- Use async/await over .then()
- Functional components over class components (React)
- Type everything (TypeScript)
- Avoid any type
-->

<!-- For Python -->
<!--
- Type hints required for functions
- Use f-strings for formatting
- Comprehensions over loops where readable
- Context managers for resources
- Specific exceptions, not bare except
-->

### Error Handling

<!-- Document your error handling patterns -->

[How to handle errors in this project - patterns, wrappers, logging]

**Example:**
```[language]
[Code example of proper error handling in your project]
```

### Testing

- **Framework:** [Jest, pytest, go test, etc.]
- **Style:** [Unit, integration, e2e patterns]
- **Coverage threshold:** [e.g., 80%]
- **Approach:** [TDD, test after, etc.]

**Test Pattern:**
```[language]
[Example test following your project's pattern]
```

---

## Simplicity Principles

<!-- CRITICAL: Document anti-patterns to prevent over-engineering -->

### Anti-Patterns to AVOID

<!-- Be specific about what NOT to do -->

❌ **NEVER:**
- Over-engineer simple features
- Add unnecessary abstractions
- Create helpers/utilities for one-time operations
- Design for hypothetical future requirements
- Build complex multi-layer architectures for simple tasks
- Generate long code blocks or entire files at once
- Use placeholder comments like `// ... rest of code ...`
- [Add project-specific anti-patterns here]

### Enforcement Rules

✅ **ALWAYS:**
- Choose the simplest practical solution
- Three similar lines > premature abstraction
- Only introduce complexity if clearly justified
- Make minimal, surgical changes
- Examine codebase for similar patterns FIRST
- Fit seamlessly with established architecture
- Reuse existing components/utilities/logic
- Consistency > perfection

### Complexity Check

**Before implementing, ask:**
1. Can this be simpler?
2. Am I adding abstractions needed NOW (not future)?
3. Does similar code exist I can reuse?
4. Is this the minimal change to achieve the goal?

**If unsure:** STOP and ask for approval before proceeding.

### Pattern Drift Threats

<!-- Document areas where Claude tends to over-complicate in YOUR codebase -->

[Specific areas/patterns where over-engineering commonly occurs]

**Example:**
- API handlers: Claude tends to add middleware layers unnecessarily. Keep simple: validate → call service → return response.
- [Add your specific patterns here]

---

## Code Generation Rules

<!-- Prevent long, untested code blocks -->

### ALWAYS

- Show **complete code** (no placeholders)
- **Incremental changes** - small focused steps (20-50 lines)
- **Surgical, minimal** changes only
- **Test-driven development** when appropriate
- **Follow existing patterns** found in codebase
- **Ask questions** before assuming requirements

### NEVER

- Generate entire long files at once
- Generate >100 lines in single response
- Make big changes in single step
- Modify code unrelated to the task
- Assume requirements without asking
- Add features beyond what's requested
- Use placeholders like `// ... rest of code ...`

### Incremental Development Process

**Break changes into steps:**
1. Define interfaces/types
2. Implement core logic (minimal)
3. Add error handling
4. Add tests
5. Iterate

**Each step:** Review, approve, then proceed to next.

---

## Common Commands

<!-- Document frequently used commands - saves time and ensures consistency -->

### Development

```bash
# Build
[your build command]

# Run locally
[your run/start command]

# Test
[your test command]

# Lint
[your lint command]

# Format
[your format command]
```

### Git Conventions

- **Branch naming:** [e.g., feat/description, fix/description]
- **Commit message format:** [e.g., type: description, conventional commits]
- **PR process:** [workflow, requirements]
- **Commit signing:** [e.g., -s -S flags required]

**Example commit:**
```
[type]: [summary in 50 chars or less]

[Detailed description wrapped at 72 chars]

[Reference to issue if applicable]
```

### [Domain-Specific Commands]

<!-- For infrastructure projects -->
<!--
```bash
# Kubernetes
kubectl get pods -n [namespace]
kubectl apply -f [manifest]

# Terraform
terraform plan
terraform apply

# Docker
docker build -t [image:tag] .
docker-compose up
```
-->

---

## [Domain-Specific Patterns]

<!-- For Infrastructure/DevOps Projects -->
<!--
## Infrastructure Patterns

### Kubernetes
- Namespace conventions: [specify]
- Deployment strategy: [blue-green/canary/rolling]
- Always include: health checks, rollback mechanisms, monitoring
- Resource limits: [specify defaults]
- RBAC: least-privilege by default

### Networking
- [Security group/firewall conventions]
- [Load balancer patterns]
- [Network policy requirements]

### Terraform/IaC
- [Module organization]
- Least-privilege by default
- Document every permission with justification
- [State management patterns]
-->

<!-- For Web Applications -->
<!--
## Application Patterns

### API Design
- [RESTful conventions, GraphQL patterns]
- [Authentication/authorization approach]
- [Rate limiting, caching strategies]

### Data Management
- [Database patterns, ORM usage]
- [Migration strategy]
- [Data validation approach]

### Frontend
- [Component structure]
- [State management]
- [Routing patterns]
-->

---

## Project-Specific Context

<!-- Domain knowledge Claude needs to generate appropriate code -->

### Domain Knowledge

[Key concepts, terminology, business logic specific to your domain]

**Example:**
- [Concept]: [Explanation]
- [Pattern]: [How it's used in this project]

### Known Issues & Gotchas

<!-- Warn Claude about common pitfalls -->

- [Issue description and how to handle]
- [Gotcha and workaround]
- [Complex area requiring extra care]

### Integration Points

<!-- External services, APIs, dependencies -->

- **[Service Name]:** [Purpose, how it's used]
- **[API Name]:** [Authentication, endpoints, patterns]
- **[Dependency]:** [Why it's used, limitations]

---

## Additional Resources

<!-- Links to key documentation -->

- **Architecture docs:** [link or path]
- **API specifications:** [link or path]
- **Design docs:** [link or path]
- **Runbooks:** [link or path]
- **Team wiki:** [link]

---

## Notes for Maintaining This File

<!-- Guidelines for keeping CLAUDE.md useful -->

**Do:**
- Update when architecture changes
- Add patterns as they emerge
- Keep under 500 lines
- Review monthly with team
- Update based on PR review feedback

**Don't:**
- Add generic programming advice
- Include outdated patterns
- Let it grow beyond 1000 lines
- Forget to update when conventions change

---

<!--
TEMPLATE USAGE NOTES:

1. **Remove all HTML comments** (like this one) before using
2. **Replace all [placeholders]** with your project specifics
3. **Delete sections** that don't apply to your project
4. **Add sections** for project-specific needs
5. **Keep it under 500 lines** for best performance
6. **Version control** and share with team

For large codebases (300k+ LoC):
- Create subdirectory CLAUDE.md files for major modules
- Keep root CLAUDE.md high-level
- Reference subdirectory files where appropriate

To generate CLAUDE.md for your project:
- New project: Use the "generate-claude-md-new.md" prompt
- Existing project: Use the "generate-claude-md-existing.md" prompt

For more information:
- See findings/claude-md-best-practices.md for complete research
- Run `/init` in Claude Code to auto-generate a baseline
-->
